import requests
import json
from django.conf import settings
from django.utils import timezone
from datetime import timedelta
from .models import Transaction, Subscription


class PaymentService:
    def __init__(self):
        self.multicaixa_api_url = getattr(settings, 'MULTICAIXA_API_URL', '')\n        self.emis_api_url = getattr(settings, 'EMIS_API_URL', '')\n    \n    def process_payment(self, transaction, payment_method):\n        if payment_method.lower() == 'multicaixa':\n            return self._process_multicaixa_payment(transaction)\n        elif payment_method.lower() == 'emis':\n            return self._process_emis_payment(transaction)\n        else:\n            raise ValueError(f'M\u00e9todo de pagamento n\u00e3o suportado: {payment_method}')\n    \n    def _process_multicaixa_payment(self, transaction):\n        # Implementa\u00e7\u00e3o do Multicaixa Express\n        # Esta \u00e9 uma implementa\u00e7\u00e3o simples - ajustar conforme API oficial\n        \n        payload = {\n            'amount': float(transaction.amount),\n            'reference': transaction.reference,\n            'description': f'Subscri\u00e7\u00e3o {transaction.subscription.plan.name}',\n            'callback_url': f'{settings.DOMAIN}/api/payments/webhook/'\n        }\n        \n        try:\n            # Simular resposta do Multicaixa para desenvolvimento\n            # Em produ\u00e7\u00e3o, fazer requisi\u00e7\u00e3o real para API\n            if settings.DEBUG:\n                return {\n                    'success': True,\n                    'payment_url': f'https://multicaixa.ao/pay/{transaction.reference}',\n                    'reference': transaction.reference\n                }\n            \n            # C\u00f3digo real para produ\u00e7\u00e3o\n            # response = requests.post(self.multicaixa_api_url, json=payload)\n            # return response.json()\n            \n        except Exception as e:\n            transaction.status = 'FAILED'\n            transaction.save()\n            raise e\n    \n    def _process_emis_payment(self, transaction):\n        # Implementa\u00e7\u00e3o do EMIS\n        # Ajustar conforme API oficial do EMIS\n        \n        payload = {\n            'amount': float(transaction.amount),\n            'reference': transaction.reference,\n            'description': f'Subscri\u00e7\u00e3o {transaction.subscription.plan.name}'\n        }\n        \n        try:\n            # Simular resposta do EMIS para desenvolvimento\n            if settings.DEBUG:\n                return {\n                    'success': True,\n                    'payment_url': f'https://emis.ao/pay/{transaction.reference}',\n                    'reference': transaction.reference\n                }\n            \n            # C\u00f3digo real para produ\u00e7\u00e3o\n            # response = requests.post(self.emis_api_url, json=payload)\n            # return response.json()\n            \n        except Exception as e:\n            transaction.status = 'FAILED'\n            transaction.save()\n            raise e\n    \n    def handle_webhook(self, webhook_data):\n        try:\n            reference = webhook_data.get('reference')\n            status = webhook_data.get('status')\n            \n            transaction = Transaction.objects.get(reference=reference)\n            \n            if status == 'completed':\n                transaction.status = 'COMPLETED'\n                \n                # Ativar subscri\u00e7\u00e3o\n                subscription = transaction.subscription\n                subscription.status = 'ACTIVE'\n                subscription.start_date = timezone.now()\n                subscription.end_date = timezone.now() + timedelta(days=subscription.plan.duration_days)\n                subscription.save()\n                \n            elif status == 'failed':\n                transaction.status = 'FAILED'\n                transaction.subscription.status = 'CANCELLED'\n                transaction.subscription.save()\n            \n            transaction.save()\n            return {'success': True}\n            \n        except Transaction.DoesNotExist:\n            return {'success': False, 'error': 'Transa\u00e7\u00e3o n\u00e3o encontrada'}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}